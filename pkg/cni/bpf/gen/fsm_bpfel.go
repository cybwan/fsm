// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || amd64p32 || arm || arm64 || mips64le || mips64p32le || mipsle || ppc64le || riscv64
// +build 386 amd64 amd64p32 arm arm64 mips64le mips64p32le mipsle ppc64le riscv64

package gen

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type FsmCtKeyT struct {
	Daddr [4]uint32
	Saddr [4]uint32
	Sport uint16
	Dport uint16
	Proto uint8
	V6    uint8
}

type FsmCtOpT struct {
	ActType uint8
	_       [3]byte
	Lock    struct{ Val uint32 }
	Attr    struct {
		Dir uint32
		Sm  struct {
			T struct {
				State uint32
				Fndir uint32
				Dirs  [2]struct {
					Hstate   uint16
					InitAcks uint16
					Seq      uint32
					Pack     uint32
					Pseq     uint32
				}
			}
		}
		Smr   uint32
		EpSel uint16
		Ep    struct {
			NatFlags uint8
			Nv6      uint8
			NatXifi  uint16
			NatXport uint16
			NatRport uint16
			NatXip   [4]uint32
			NatRip   [4]uint32
			NatXmac  [6]uint8
			NatRmac  [6]uint8
			Inactive uint8
		}
		_ [1]byte
	}
	Ito uint64
	Lts uint64
	Nf  struct {
		Rdr struct {
			Oport uint16
			Fin   uint16
		}
		_ [56]byte
	}
	_ [4]byte
}

type FsmDpDnatOptKey struct {
	Xaddr uint32
	Xport uint16
	Proto uint8
	V6    uint8
}

type FsmDpDnatOptTact struct {
	Daddr uint32
	Saddr uint32
	Dport uint16
	Sport uint16
	_     [4]byte
	Ts    uint64
}

type FsmDpSnatOptKey struct {
	Daddr uint32
	Saddr uint32
	Dport uint16
	Sport uint16
	Proto uint8
	V6    uint8
	_     [2]byte
}

type FsmDpSnatOptTact struct {
	Xaddr uint32
	Xport uint16
	_     [2]byte
}

type FsmFib4KeyT struct {
	Daddr uint32
	Saddr uint32
	Sport uint16
	Dport uint16
	Ifi   uint16
	Proto uint8
}

type FsmFib4OpsT struct {
	ActType uint8
	_       [7]byte
	Its     uint64
	Ops     [3]struct {
		ActType uint8
		_       [3]byte
		Nf      struct {
			Rdr struct {
				Oport uint16
				Fin   uint16
			}
			_ [56]byte
		}
	}
}

type FsmNatKeyT struct {
	Daddr [4]uint32
	Dport uint16
	Proto uint8
	V6    uint8
}

type FsmNatOpsT struct {
	Ito       uint64
	Pto       uint64
	Lock      struct{ Val uint32 }
	NatType   uint8
	LbAlgo    uint8
	EpSel     uint8
	EpCnt     uint8
	Endpoints [1]struct {
		NatFlags uint8
		Nv6      uint8
		NatXifi  uint16
		NatXport uint16
		NatRport uint16
		NatXip   [4]uint32
		NatRip   [4]uint32
		NatXmac  [6]uint8
		NatRmac  [6]uint8
		Inactive uint8
	}
	_ [3]byte
}

type FsmXpkt struct {
	Skb struct {
		Data    uint32
		DataEnd uint32
	}
	L2 struct {
		Vlan    [3]uint16
		DlType  uint16
		DlDst   [6]uint8
		DlSrc   [6]uint8
		VlanPcp uint8
		Valid   uint8
		Ssnid   uint16
	}
	L34 struct {
		Tos    uint8
		Proto  uint8
		Valid  uint8
		Frg    uint8
		Sport  uint16
		Dport  uint16
		Seq    uint32
		AckSeq uint32
		Saddr  [4]uint32
		Daddr  [4]uint32
	}
	Il2 struct {
		Vlan    [3]uint16
		DlType  uint16
		DlDst   [6]uint8
		DlSrc   [6]uint8
		VlanPcp uint8
		Valid   uint8
		Ssnid   uint16
	}
	Il34 struct {
		Tos    uint8
		Proto  uint8
		Valid  uint8
		Frg    uint8
		Sport  uint16
		Dport  uint16
		Seq    uint32
		AckSeq uint32
		Saddr  [4]uint32
		Daddr  [4]uint32
	}
	Nat struct {
		Nxip       [4]uint32
		Nrip       [4]uint32
		Nxport     uint16
		Nrport     uint16
		Nxifi      uint16
		Nxmac      [6]uint8
		Nrmac      [6]uint8
		CtSts      uint8
		EpSel      uint8
		Nv6        uint8
		XlateProto uint8
		_          [2]byte
		Ito        uint64
	}
	Ctx struct {
		Bd        uint16
		PyBytes   uint16
		Act       uint8
		L3Off     uint8
		Phit      uint16
		NhNum     uint16
		QosId     uint16
		Rcode     uint32
		Ifi       uint32
		_         [1]byte /* unsupported bitfield */
		Tc        uint8
		Pprop     uint8
		LkupDmac  [6]uint8
		Iport     uint16
		Oport     uint16
		L4Off     uint8
		TableId   uint8
		Sseid     uint64
		Dseid     uint64
		Mirr      uint16
		TcpFlags  uint8
		Nf        uint8
		L3Adj     int16
		Il3Off    uint8
		Il4Off    uint8
		ItcpFlags uint8
		_         [1]byte /* unsupported bitfield */
		L3Len     uint16
		L3Plen    uint16
		Il3Len    uint16
		Il3Plen   uint16
		TunOff    uint16
		FwMid     uint16
		FwLid     uint16
		FwRid     uint16
	}
}

// LoadFsm returns the embedded CollectionSpec for Fsm.
func LoadFsm() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_FsmBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load Fsm: %w", err)
	}

	return spec, err
}

// LoadFsmObjects loads Fsm and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*FsmObjects
//	*FsmPrograms
//	*FsmMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadFsmObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := LoadFsm()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// FsmSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type FsmSpecs struct {
	FsmProgramSpecs
	FsmMapSpecs
}

// FsmSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type FsmProgramSpecs struct {
	SidecarConnTrack *ebpf.ProgramSpec `ebpf:"sidecar_conn_track"`
	SidecarDrop      *ebpf.ProgramSpec `ebpf:"sidecar_drop"`
	SidecarEgress    *ebpf.ProgramSpec `ebpf:"sidecar_egress"`
	SidecarHandShake *ebpf.ProgramSpec `ebpf:"sidecar_hand_shake"`
	SidecarIngress   *ebpf.ProgramSpec `ebpf:"sidecar_ingress"`
	SidecarPass      *ebpf.ProgramSpec `ebpf:"sidecar_pass"`
}

// FsmMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type FsmMapSpecs struct {
	FsmCt      *ebpf.MapSpec `ebpf:"fsm_ct"`
	FsmCtOps   *ebpf.MapSpec `ebpf:"fsm_ct_ops"`
	FsmDnatOpt *ebpf.MapSpec `ebpf:"fsm_dnat_opt"`
	FsmEgrIpv4 *ebpf.MapSpec `ebpf:"fsm_egr_ipv4"`
	FsmFib4    *ebpf.MapSpec `ebpf:"fsm_fib4"`
	FsmFib4Key *ebpf.MapSpec `ebpf:"fsm_fib4_key"`
	FsmFib4Ops *ebpf.MapSpec `ebpf:"fsm_fib4_ops"`
	FsmIgrIpv4 *ebpf.MapSpec `ebpf:"fsm_igr_ipv4"`
	FsmNat     *ebpf.MapSpec `ebpf:"fsm_nat"`
	FsmProgs   *ebpf.MapSpec `ebpf:"fsm_progs"`
	FsmSnatOpt *ebpf.MapSpec `ebpf:"fsm_snat_opt"`
	FsmXpkts   *ebpf.MapSpec `ebpf:"fsm_xpkts"`
}

// FsmObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadFsmObjects or ebpf.CollectionSpec.LoadAndAssign.
type FsmObjects struct {
	FsmPrograms
	FsmMaps
}

func (o *FsmObjects) Close() error {
	return _FsmClose(
		&o.FsmPrograms,
		&o.FsmMaps,
	)
}

// FsmMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadFsmObjects or ebpf.CollectionSpec.LoadAndAssign.
type FsmMaps struct {
	FsmCt      *ebpf.Map `ebpf:"fsm_ct"`
	FsmCtOps   *ebpf.Map `ebpf:"fsm_ct_ops"`
	FsmDnatOpt *ebpf.Map `ebpf:"fsm_dnat_opt"`
	FsmEgrIpv4 *ebpf.Map `ebpf:"fsm_egr_ipv4"`
	FsmFib4    *ebpf.Map `ebpf:"fsm_fib4"`
	FsmFib4Key *ebpf.Map `ebpf:"fsm_fib4_key"`
	FsmFib4Ops *ebpf.Map `ebpf:"fsm_fib4_ops"`
	FsmIgrIpv4 *ebpf.Map `ebpf:"fsm_igr_ipv4"`
	FsmNat     *ebpf.Map `ebpf:"fsm_nat"`
	FsmProgs   *ebpf.Map `ebpf:"fsm_progs"`
	FsmSnatOpt *ebpf.Map `ebpf:"fsm_snat_opt"`
	FsmXpkts   *ebpf.Map `ebpf:"fsm_xpkts"`
}

func (m *FsmMaps) Close() error {
	return _FsmClose(
		m.FsmCt,
		m.FsmCtOps,
		m.FsmDnatOpt,
		m.FsmEgrIpv4,
		m.FsmFib4,
		m.FsmFib4Key,
		m.FsmFib4Ops,
		m.FsmIgrIpv4,
		m.FsmNat,
		m.FsmProgs,
		m.FsmSnatOpt,
		m.FsmXpkts,
	)
}

// FsmPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadFsmObjects or ebpf.CollectionSpec.LoadAndAssign.
type FsmPrograms struct {
	SidecarConnTrack *ebpf.Program `ebpf:"sidecar_conn_track"`
	SidecarDrop      *ebpf.Program `ebpf:"sidecar_drop"`
	SidecarEgress    *ebpf.Program `ebpf:"sidecar_egress"`
	SidecarHandShake *ebpf.Program `ebpf:"sidecar_hand_shake"`
	SidecarIngress   *ebpf.Program `ebpf:"sidecar_ingress"`
	SidecarPass      *ebpf.Program `ebpf:"sidecar_pass"`
}

func (p *FsmPrograms) Close() error {
	return _FsmClose(
		p.SidecarConnTrack,
		p.SidecarDrop,
		p.SidecarEgress,
		p.SidecarHandShake,
		p.SidecarIngress,
		p.SidecarPass,
	)
}

func _FsmClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed fsm_bpfel.o
var _FsmBytes []byte
